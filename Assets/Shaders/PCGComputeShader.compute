// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define MAX_BRANCHES 1
#define MAX_ITERATIONS 2

typedef vector<int, MAX_BRANCHES> intVector;

struct BranchData
{
	float4 branchRotation;

	float branchScale;

	int numberOfChildBranches;
	int connectedChildBranches;

	intVector childBranchesIdx;
};

BranchData CreateDefaultBranchData()
{
    BranchData defaultData;
    
    defaultData.branchRotation = float4(0, 0, 0, 1);
    
    defaultData.branchScale = 1.0f;
    
    defaultData.numberOfChildBranches = 0;
    defaultData.connectedChildBranches = 0;
    
    for (int i = 0; i < MAX_BRANCHES; i++)
    {
        defaultData.childBranchesIdx[i] = -1;;
    }
    
    return defaultData;
}

AppendStructuredBuffer<BranchData> dataBuffer;
RWStructuredBuffer<int> argsBuffer;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Info required to recursively generate the tree
	int createdBranches = 0;
	int branchesToCreate = 0;

	int workingIteration = 0;

	BranchData workingBranchTree[MAX_ITERATIONS];


	// Creating the start of the tree
    BranchData treeStart = CreateDefaultBranchData();
	// Handling branch rotation
    treeStart.branchRotation = float4(0, 0, 0, 1);
	// Handling branch size
	treeStart.branchScale = 1.0f;
	// Setting up child branch connections
	treeStart.numberOfChildBranches = (int) MAX_BRANCHES;
    treeStart.connectedChildBranches = 0;
	branchesToCreate = (int) MAX_BRANCHES;
    
    // Adding new branch to buffer and storing the the working tree
    dataBuffer.Append(treeStart);
    argsBuffer[0] = (createdBranches + 1);
    workingBranchTree[0] = treeStart;


	// Compute shaders don't support recursive methods so the algorithm needs to be restructured to work with a while loop
	bool isComplete = false;
	while (!isComplete)
	{
		// Checking if the tree has finished generating
		if ((createdBranches == (branchesToCreate)) && (workingIteration == (MAX_ITERATIONS - 1)))
		{
			isComplete = true;
		}
		// Otherwise gets the next branch to generate
		else
		{
			// If the current branch is at the end of the tree then need to backtrack till a unfinished branch is found
			if (workingIteration == (MAX_ITERATIONS - 1))
			{
				bool suitableBranchFound = false;
				while (!suitableBranchFound)
				{
					// Cleaning up working tree
					//workingBranchTree[workingIteration] = NULL;

					// Moving back up the tree
					workingIteration--;
					// Checking that if the backtracking has found no suitable branch to build from
					if (workingIteration == -1)
					{
						//UnityEngine.Debug.LogError("ERROR: No suitable branch found to build from");
						//UnityEngine.Debug.Break();
					}
					BranchData branchToCheck = workingBranchTree[workingIteration];

					// Checking if that branch has had all of it's sub branches made
					// If not then the generation can continue with that branch
					if (branchToCheck.connectedChildBranches != branchToCheck.numberOfChildBranches)
					{
						suitableBranchFound = true;
					}
				}
			}

			// Then build off of the current branch
			BranchData previousBranch = workingBranchTree[workingIteration];

			// "Creating" new branch
			createdBranches++;
            BranchData newBranch = CreateDefaultBranchData();;
			workingIteration++;
			workingBranchTree[workingIteration] = newBranch;

			// Setting the details of the new branch
			// Handling branch size
			newBranch.branchScale = 1.0f;
			// Handling branch rotation
			//newBranch.branchRotation = Quaternion.Euler(branchAngleMax, ((360.0f / previousBranch.numberOfChildBranches) * previousBranch.connectedChildBranches), 0);

			// Checking if child branches should be added to the new branch
			if (workingIteration < (MAX_ITERATIONS - 1))
			{
				newBranch.numberOfChildBranches = (int) MAX_BRANCHES;
				branchesToCreate += (int) MAX_BRANCHES;
			}

			// Connecting the previous branch to the new branch
			int idx = previousBranch.connectedChildBranches;
			intVector mb = previousBranch.childBranchesIdx;
			mb[idx] = createdBranches;
			previousBranch.connectedChildBranches++;
            
            // Adding the new branch to the buffer
            dataBuffer.Append(newBranch);
            argsBuffer[0] = (createdBranches + 1);
        }
	}
}